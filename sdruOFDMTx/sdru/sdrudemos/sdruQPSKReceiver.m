%% QPSK Receiver with USRP(R) Hardware
% This example shows how to use the Universal Software Radio Peripheral(R)
% (USRP(R)) device using SDRu (Software Defined Radio USRP(R)) System
% objects to implement a QPSK receiver. The receiver addresses practical
% issues in wireless communications, such as carrier frequency and phase
% offset, timing offset and frame synchronization. This system receives the
% signal sent by the <matlab:edit('sdruQPSKReceiver.m') QPSK Transmitter
% with USRP(R) Hardware> example. The receiver demodulates the received
% symbols and prints a simple message to the MATLAB(R) command line.
%
% Please refer to <../../help/index.html Getting Started> for details on
% configuring your host computer to work with the SDRu Receiver System object.
%
% Copyright 2012 The MathWorks, Inc.

%% Implementations
% This example describes the MATLAB implementation of a QPSK receiver with 
% USRP(R) Hardware. There is another implementation of this example that uses 
% Simulink(R).
%
% MATLAB script using System objects:
% <matlab:edit('sdruQPSKReceiver.m') sdruQPSKReceiver.m>.
%
% Simulink implementation using blocks: <matlab:sdruqpskrx sdruqpskrx.mdl>.
%
% You can also explore a no-USRP QPSK Transmitter and Receiver example that
% models a general wireless communication system using an AWGN channel and
% simulated channel impairments at
% <matlab:edit('commQPSKTransmitterReceiver.m') commQPSKTransmitterReceiver.m>.

%% Introduction
% This example has the following motivation:
%
% * To implement a real QPSK-based transmission-reception environment in
% MATLAB using SDRu System objects.
%
% * To illustrate the use of key Communications System Toolbox(TM) System
% objects for QPSK system design, including coarse and fine carrier
% frequency compensation, closed-loop timing recovery with bit stuffing and
% stripping, frame synchronization, carrier phase ambiguity resolution, and
% message decoding.
%
% In this example, the SDRuReceiver System object receives data
% corrupted by the transmission over the air and outputs complex baseband
% signals which are processed by the QPSK Receiver System object. 
% This example provides a reference design of a practical digital receiver
% that can cope with wireless channel impairments. The receiver includes
% FFT-based coarse frequency compensation, PLL-based fine frequency
% compensation, timing recovery with fixed-rate resampling and bit
% stuffing/skipping, frame synchronization, and phase ambiguity resolution.

%% Initialization
% The <matlab:edit('sdruqpskreceiver_init.m') sdruqpskreceiver_init.m>
% script initializes the simulation parameters and generates the structure
% _prmQPSKReceiver_.
prmQPSKReceiver = sdruqpskreceiver_init % Receiver parameter structure
compileIt  = false; % true if code is to be compiled for accelerated execution
useCodegen = false; % true to run the latest generated code (mex file) instead of MATLAB code

%%
% To transmit successfully, ensure that the specified center frequency of
% the SDRu Receiver is within the acceptable range of your USRP(R)
% daughterboard.
%
% Also, by using the compileIt and useCodegen flags, you can interact with
% the code to explore different execution options.  Set the MATLAB variable
% compileIt to true in order to generate C code; this can be
% accomplished by using the *codegen* command provided by the MATLAB
% Coder(TM) product. The *codegen* command compiles MATLAB(R) functions to
% a C-based static or dynamic library, executable, or MEX file, producing
% code for accelerated execution. The generated executable runs several times
% faster than the original MATLAB code. Set useCodegen to true to run the
% executable generated by *codegen* instead of the MATLAB code.

%% Code Architecture
% The function runSDRuQPSKReceiver implements the QPSK receiver using
% two System objects, QPSKReceiver and comm.SDRuReceiver. 
%
% *SDRu Receiver*
%
% This example communicates with the USRP(R) board using the SDRu
% receiver System object. You can supply the IP address of the USRP(R)
% board as an argument when you construct the object. The IP address can be
% any address within the same sub-network as the host computer. This example
% configures the SDRu object to use the default address 192.168.10.2. The
% parameter structure _prmQPSKReceiver_ sets the CenterFrequency, Gain, and
% InterpolationFactor arguments.
%
% *QPSK Receiver*
%
% This component regenerates the original transmitted message. It is
% divided into five subcomponents, modeled using System objects. Each
% subcomponent is modeled by other subcomponents using System objects.
%
% 1) Automatic Gain Control: Ensures that the amplitude of the input of the
% *Coarse Frequency Compensation* object is _1/Upsampling Factor_ , so
% that the equivalent gains of the phase and timing error detectors keep
% constant over time. The AGC is placed before the *Raised Cosine Receive
% Filter* so that the signal amplitude can be measured with an oversampling
% factor of four. This process improves the accuracy of the estimate.
%
% 2) Coarse frequency compensation: Uses nonlinearity and a Fast Fourier
% Transform (FFT) to roughly estimate the frequency offset and then compensate
% for it. The object raises the input signal to the power of four to 
% obtain a signal that is not a function of the QPSK modulation. Then it  
% performs an FFT on the modulation-independent signal to estimate the tone  
% at four times the frequency offset. After dividing the estimate by four,
% the *Phase/Frequency Offset* System object corrects the frequency offset.
%
% 3) Fine frequency compensation: Performs closed-loop scalar processing and
% compensates for the frequency offset accurately. The Fine Frequency  
% Compensation object implements a phase-locked loop (PLL) to track the 
% residual frequency offset and the phase offset in the input signal. 
% For more information, see Chapter 7 of [ <#9 1> ]. The PLL uses a 
% *Direct Digital Synthesizer (DDS)* to generate the compensating phase
% that offsets the residual frequency and phase offsets. The phase offset  
% estimate from *DDS* is the integral of the phase error output of the 
% *Loop Filter*. To obtain details of PLL design, refer to Appendix C.2 of 
% [ <#9 1> ].
%
% 4) Timing recovery: Performs timing recovery with closed-loop scalar
% processing to overcome the effects of delay introduced by the channel.
% The *Timing Recovery* object implements a PLL, described in Chapter 8
% of [ <#9 1> ], to correct the timing error in the received signal. The
% *NCO Control* object implements a decrementing modulo-1 counter
% described in Chapter 8.4.3 of [ <#9 1> ] to generate the control signal
% for the *Modified Buffer* to select the interpolants of the
% *Interpolation Filter*. This control signal also enables the *Timing
% Error Detector (TED)*, so that it calculates the timing errors at the
% correct timing instants. The *NCO Control* object updates the timing
% difference for the *Interpolation Filter* , generating interpolants at
% optimum sampling instants. The *Interpolation Filter* is a Farrow
% parabolic filter with alpha set to 0.5 as described in Chapter 8.4.2 of 
% [ <#9 1> ]. Based on the interpolants, timing errors are generated by a
% zero-crossing *Timing Error Detector* as described in Chapter 8.4.1 of 
% [ <#9 1> ], filtered by a tunable proportional-plus-integral *Loop Filter*
% as described in Appendix C.2 of [ <#9 1> ], and fed into the *NCO
% Control* for a timing difference update. The _Loop Bandwidth_ (normalized
% by the sample rate) and _Loop Damping Factor_ are tunable for the *Loop
% Filter*. The default normalized loop bandwidth is set to 0.01 and the
% default damping factor is set to 1 for critical damping. These settings
% ensure that the PLL quickly locks to the correct timing while introducing
% little phase noise.
%
% 5) Data decoder: Uses a Barker code to perform frame synchronization, phase 
% ambiguity resolution, and demodulation. Also, the data decoder compares 
% the regenerated message with the transmitted message and calculates the BER.
%
% For more information about the system components, refer to the
% <matlab:sdruqpskrx QPSK Receiver with USRP(R) Hardware example using
% Simulink>.

%% Execution and Results
% Before running the script, first turn on the USRP(R) and connect it to the
% computer. To ensure data reception, first start the
% <matlab:edit('sdruQPSKTransmitter.m') QPSK Transmitter with USRP(R)
% Hardware> example.

if compileIt
    compilesdru('runSDRuQPSKReceiver','mex', '-args', {coder.Constant(prmQPSKReceiver)});
end
if useCodegen
   clear runSDRuQPSKReceiver_mex %#ok<UNRCH>
   BER = runSDRuQPSKReceiver_mex(prmQPSKReceiver);
else
   BER = runSDRuQPSKReceiver(prmQPSKReceiver); 
end

fprintf('Error rate is = %f.\n',BER(1));
fprintf('Number of detected errors = %d.\n',BER(2));
fprintf('Total number of compared samples = %d.\n',BER(3));

%%
% When you run the simulations, the received messages are decoded and
% printed out in the MATLAB command window while the simulation is running.
% BER information is also shown at the end of the script execution. The
% calculation of the BER value includes the first received frames, when
% some of the adaptive components in the QPSK receiver still have not
% converged.  During this period, the BER is quite high.  Once the
% transient period is over, the receiver is able to estimate the transmitted
% frame and the BER dramatically improves. In this example, to guarantee a
% reasonable execution time of the system in simulation mode, the
% simulation duration is fairly short.  As such, the overall BER results
% are significantly affected by the high BER values at the beginning of the
% simulation. To increase the simulation duration and obtain lower BER
% values,  you can change the SimParams.StopTime variable in the
% <matlab:edit('sdruqpskreceiver_init.m') receiver initialization file>.
%
% Also, the gain behavior of different USRP(R) daughter boards varies
% considerably. Thus, the gain setting in the transmitter and receiver
% defined in this example may not be well-suited for your daughter boards.
% If the message is not properly decoded by the receiver system, you can
% vary the gain of the source signals in the *SDRu Transmitter* and *SDRu
% Receiver* System objects by changing the SimParams.USRPGain value in the
% <matlab:edit('sdruqpsktransmitter_init.m') transmitter initialization
% file> and in the <matlab:edit('sdruqpskreceiver_init.m') receiver
% initialization file>.
%
% Finally, a large relative frequency offset between the transmit and receive
% USRP(R) radios can prevent the receiver functions from properly decoding
% the message.  If that happens, you can determine the offset by sending a
% tone at a known frequency from the transmitter to the receiver, then
% measuring the offset between the transmitted and received frequency, then
% applying that offset to the center frequency of the SDRu Receiver System
% object.

%% Appendix
% This example uses the following script and helper functions:
%
% * <matlab:edit('runSDRuQPSKReceiver.m') runSDRuQPSKReceiver.m>
% * <matlab:edit('sdruqpskreceiver_init.m') sdruqpskreceiver_init.m>
% * <matlab:edit('sdruQPSKRx.m') sdruQPSKRx.m>
% * <matlab:edit('sdruQPSKDataDecoder.m') sdruQPSKDataDecoder.m>
% * <matlab:edit('QPSKCoarseFrequencyCompensator.m') QPSKCoarseFrequencyCompensator.m>
% * <matlab:edit('QPSKFineFrequencyCompensator.m') QPSKFineFrequencyCompensator.m>
% * <matlab:edit('QPSKTimingRecovery.m') QPSKTimingRecovery.m>

%% References
% 1. Rice, Michael. _Digital Communications - A Discrete-Time
% Approach_. 1st ed. New York, NY: Prentice Hall, 2008.

%% Copyright Notice
% Universal Software Radio Peripheral(R) and USRP(R) are trademarks of
% National Instruments Corp.