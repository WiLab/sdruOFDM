%% File : usrp_uhd_sfunrx.tlc
%%
%% Description: 
%%   Simulink Coder TLC Code Generation file for usrp_uhd_sfunrx
%%
%% Simulink version      : 8.0 (R2012a Prerelease) 18-Aug-2011
%% TLC file generated on : 23-Sep-2011 18:40:57

/%
     %%%-MATLAB_Construction_Commands_Start
     def = legacy_code('initialize');
     def.SFunctionName = 'usrp_uhd_sfunrx';
     def.OutputFcnSpec = 'void receiveData_c(  int32  work4, double u1, double u2, double u3, double u4, complex<int16> y1[p3], uint32 y2[1], uint32 y3[1], UsrpErrorSLCapiEnumT work2[1], int8 work3[1024])';
     def.StartFcnSpec = 'void openDataConnection_c(  int8 p1[], BoardIdSLCapiEnumT p2, int8 work1[1024], uint32 p3, DataPortDataTypeSLCapiEnumT p4, BufferModeSLCapiEnumT p5, uint32 p6, int32 work4[1], UsrpErrorSLCapiEnumT work2[1], int8 work3[1024])';
     def.TerminateFcnSpec = 'void closeDataConnection_c(  int32 work4, UsrpErrorSLCapiEnumT work2[1], int8 work3[1024])';
     def.HeaderFiles = {'usrp_uhd_capi.hpp', 'usrp_sfun_setshs.hcpp'};
     def.SampleTime = 'parameterized';
     def.Options.isMacro = true;
     def.Options.useTlcWithAccel = false;
     legacy_code('sfcn_tlc_generate', def);
     %%%-MATLAB_Construction_Commands_End
 %/

%implements usrp_uhd_sfunrx "C"

%% Function: FcnGenerateUniqueFileName ====================================
%%
%function FcnGenerateUniqueFileName(filename, type) void
  %%
  %assign isReserved = TLC_FALSE
  %foreach idxFile = CompiledModel.DataObjectUsage.NumFiles[0]
    %assign thisFile = CompiledModel.DataObjectUsage.File[idxFile]
    %if (thisFile.Name==filename) && (thisFile.Type==type)
      %assign isReserved = TLC_TRUE
      %break
    %endif
  %endforeach
  %if (isReserved==TLC_TRUE)
    %assign filename = FcnGenerateUniqueFileName(filename + "_", type)
  %endif
  %return filename
  %%
%endfunction

%% Function: BlockTypeSetup ===============================================
%%
%function BlockTypeSetup(block, system) void
  %%
  %% The Target Language must be C
  %if ::GenCPP==1
    %<LibReportFatalError("This S-Function generated by the Legacy Code Tool must be only used with the C Target Language")>
  %endif

  %assign ver = FEVAL("ver", "simulink")
  %assign factor = 1.0
  %assign slVer = 0.0
  %foreach idx = SIZE(ver.Version)[1]
    %if ISEQUAL(ver.Version[idx], ".")
      %assign factor = factor/10.0
    %else
      %assign slVer = slVer + %<ver.Version[idx]>*factor
    %endif
  %endforeach

  %if GenerateErtSFunction==1 && slVer < 6.21
    %<LibReportFatalError("S-Functions generated by the Legacy Code Tool (that use Simulink Object) may not be used in a model for which an ERT S-Function wrapper is being generated")>
  %endif

  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"

    %assign hFileName = FcnGenerateUniqueFileName("usrp_uhd_sfunrx_wrapper", "header")
    %assign hFileNameMacro = FEVAL("upper", hFileName)
    %openfile hFile = "%<hFileName>.h"
    %selectfile hFile
    #ifndef _%<hFileNameMacro>_H_
    #define _%<hFileNameMacro>_H_

    #include "tmwtypes.h"

    extern void usrp_uhd_sfunrx_wrapper_start( const int8_T *p1, const void *p2,  int8_T *work1, const uint32_T p3, const void *p4, const void *p5, const uint32_T p6,  int32_T *work4,  void *work2,  int8_T *work3);

    extern void usrp_uhd_sfunrx_wrapper_output(  int32_T work4, const real_T u1, const real_T u2, const real_T u3, const real_T u4,  cint16_T *y1,  uint32_T *y2,  uint32_T *y3,  void *work2,  int8_T *work3);

    extern void usrp_uhd_sfunrx_wrapper_terminate(  int32_T work4,  void *work2,  int8_T *work3);

    #endif
    %closefile hFile

    %assign cFileName = FcnGenerateUniqueFileName("usrp_uhd_sfunrx_wrapper", "source")
    %openfile cFile = "%<cFileName>.c"
    %selectfile cFile
    #include <string.h>
    #include "tmwtypes.h"
    #include "usrp_uhd_capi.hpp"

    void usrp_uhd_sfunrx_wrapper_start( const int8_T *p1, const void *p2,  int8_T *work1, const uint32_T p3, const void *p4, const void *p5, const uint32_T p6,  int32_T *work4,  void *work2,  int8_T *work3) {


      openDataConnection_c( (int8_T*)(p1), *(BoardIdCapiEnumT *) p2, (char *) work1, (uint32_T)(p3), *(DataPortDataTypeCapiEnumT *) p4, *(BufferModeSLCapiEnumT *) p5, (uint32_T)(p6), work4, (UsrpErrorCapiEnumT *) work2, work3);

    }

    void usrp_uhd_sfunrx_wrapper_output(  int32_T work4, const real_T u1, const real_T u2, const real_T u3, const real_T u4,  cint16_T *y1,  uint32_T *y2,  uint32_T *y3,  void *work2,  int8_T *work3) {


      receiveData_c( work4, (real_T)(u1), (real_T)(u2), (real_T)(u3), (real_T)(u4), y1, y2, y3, (UsrpErrorCapiEnumT *) work2, work3);

    }

    void usrp_uhd_sfunrx_wrapper_terminate(  int32_T work4,  void *work2,  int8_T *work3) {


      closeDataConnection_c( work4, (UsrpErrorCapiEnumT *) work2, work3);

    }

    %closefile cFile

    %<LibAddToCommonIncludes("%<hFileName>.h")>
        %<LibAddToModelSources("%<cFileName>")>

  %else

    %<LibAddToCommonIncludes("usrp_uhd_capi.hpp")>

  %endif


  %%
%endfunction

%% Function: BlockInstanceSetup ===========================================
%%
%function BlockInstanceSetup(block, system) void
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
  %else
    %<LibBlockSetIsExpressionCompliant(block)>
  %endif
  %%
%endfunction

%% Function: Start ========================================================
%%
%function Start(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
    %assign p1_ptr = LibBlockParameterBaseAddr(p1)
    %assign p2_val = LibBlockParameter(p2, "", "", 0)
    %assign p3_val = LibBlockParameter(p3, "", "", 0)
    %assign p4_val = LibBlockParameter(p4, "", "", 0)
    %assign p5_val = LibBlockParameter(p5, "", "", 0)
    %assign p6_val = LibBlockParameter(p6, "", "", 0)
    %assign work1_ptr = LibBlockDWorkAddr(work1, "", "", 0)
    %assign work4_ptr = LibBlockDWorkAddr(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    {
      BoardIdCapiEnumT p2_val = %<p2_val>;
      DataPortDataTypeCapiEnumT p4_val = %<p4_val>;
      BufferModeCapiEnumT p5_val = %<p5_val>;
      usrp_uhd_sfunrx_wrapper_start( %<p1_ptr>, (void *)&p2_val, %<work1_ptr>, %<p3_val>, (void *)&p4_val, (void *)&p5_val, %<p6_val>, %<work4_ptr>, %<work2_ptr>, %<work3_ptr>);
    }
  %else 
    %assign p1_ptr = LibBlockParameterBaseAddr(p1)
    %assign p2_val = LibBlockParameter(p2, "", "", 0)
    %assign p3_val = LibBlockParameter(p3, "", "", 0)
    %assign p4_val = LibBlockParameter(p4, "", "", 0)
    %assign p5_val = LibBlockParameter(p5, "", "", 0)
    %assign p6_val = LibBlockParameter(p6, "", "", 0)
    %assign work1_ptr = LibBlockDWorkAddr(work1, "", "", 0)
    %assign work4_ptr = LibBlockDWorkAddr(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %assign dhn = SFcnParamSettings.DHN

    %assign reqIdStr = LibGetFormattedBlockPath(block)
    %%
    /* start of code for: %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    {
    char   newip[1024];
    size_t dhnlen;

    %% Set values on dwork for requesterId string
    strncpy((char *)%<work1_ptr>, "%<reqIdStr>", 1024);

    %if isRAccel
      strncpy(newip, (char *)%<p1_ptr>, 1024);
    %else
      dhnlen = strlen("%<dhn>");
      strncpy(newip, "%<dhn>", 1024);
    %endif

    openDataConnection_c( newip, (BoardIdCapiEnumT)%<p2_val>, (char *) %<work1_ptr>, (uint32_T)%<p3_val>, (DataPortDataTypeCapiEnumT)%<p4_val>, (BufferModeCapiEnumT)%<p5_val>, (uint32_T)%<p6_val>, %<work4_ptr>, %<work2_ptr>, (char *) %<work3_ptr>);

    %% for rapid accelerator, report the error BUT NOT THROUGH THE BLOCK! (That'll
    %% just hang Simulink!)
    %if isRAccel 
        if (*%<work2_ptr> != UsrpDriverSuccess) {
            ssSetErrorStatus(rtS, (char *) %<work3_ptr>);
        }
    %% for stand-alone executables, just exit
    %else
    if (*%<work2_ptr> != UsrpDriverSuccess) {
        fprintf(stderr, "%s\n", (char *) %<work3_ptr>); 
        exit(-1);
    }
    %endif
    } /* end of code for: %<Type> (%<ParamSettings.FunctionName>): %<Name> */

  %endif 
  %%
%endfunction

%% Function: Outputs ======================================================
%%
%function Outputs(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
    %assign u1_val = LibBlockInputSignal(0, "", "", 0)
    %assign u2_val = LibBlockInputSignal(1, "", "", 0)
    %assign u3_val = LibBlockInputSignal(2, "", "", 0)
    %assign u4_val = LibBlockInputSignal(3, "", "", 0)
    %assign y1_ptr = LibBlockOutputSignalAddr(0, "", "", 0)
    %assign y2_ptr = LibBlockOutputSignalAddr(1, "", "", 0)
    %assign y3_ptr = LibBlockOutputSignalAddr(2, "", "", 0)
    %assign work4_val = LibBlockDWork(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
      usrp_uhd_sfunrx_wrapper_output( %<work4_val>, %<u1_val>, %<u2_val>, %<u3_val>, %<u4_val>, %<y1_ptr>, %<y2_ptr>, %<y3_ptr>, %<work2_ptr>, %<work3_ptr>);
  %else 
    %assign u1_val = LibBlockInputSignal(0, "", "", 0)
    %assign u2_val = LibBlockInputSignal(1, "", "", 0)
    %assign u3_val = LibBlockInputSignal(2, "", "", 0)
    %assign u4_val = LibBlockInputSignal(3, "", "", 0)
    %assign y1_ptr = LibBlockOutputSignalAddr(0, "", "", 0)
    %assign y2_ptr = LibBlockOutputSignalAddr(1, "", "", 0)
    %assign y3_ptr = LibBlockOutputSignalAddr(2, "", "", 0)
    %assign work4_val = LibBlockDWork(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    receiveData_c( %<work4_val>, (real_T)%<u1_val>, (real_T)%<u2_val>,
            (real_T)%<u3_val>, (real_T)%<u4_val>, %<y1_ptr>, %<y2_ptr>,
            %<y3_ptr>, %<work2_ptr>, (char *) %<work3_ptr>);

    %% for rapid accelerator, report the error BUT NOT THROUGH THE BLOCK! (That'll
    %% just hang Simulink!)
    %if isRAccel 
        if (*%<work2_ptr> != UsrpDriverSuccess) {
            ssSetErrorStatus(rtS, (char *) %<work3_ptr>);
        }
    %% for stand-alone executables, just exit
    %else
    if (*%<work2_ptr> != UsrpDriverSuccess) {
        fprintf(stderr, "%s\n", (char *) %<work3_ptr>); 
        exit(-1);
    }
    %endif
  %endif 
  %%
%endfunction

%% Function: Terminate ====================================================
%%
%function Terminate(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function"
    %assign work4_val = LibBlockDWork(work4, "", "", 0)
    %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
    %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
    %%
    /* %<Type>(%<ParamSettings.FunctionName>): %<Name> */
    usrp_uhd_sfunrx_wrapper_terminate( %<work4_val>, %<work2_ptr>, %<work3_ptr>);
  %else 
   %assign work4_val = LibBlockDWork(work4, "", "", 0)
   %assign work2_ptr = LibBlockDWorkAddr(work2, "", "", 0)
   %assign work3_ptr = LibBlockDWorkAddr(work3, "", "", 0)
   %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
   closeDataConnection_c( %<work4_val>, %<work2_ptr>, (char *) %<work3_ptr>);

    %% for rapid accelerator, report the error BUT NOT THROUGH THE BLOCK! (That'll
    %% just hang Simulink!)
    %if isRAccel 
        if (*%<work2_ptr> != UsrpDriverSuccess) {
            ssSetErrorStatus(rtS, (char *) %<work3_ptr>);
        }
    %% for stand-alone executables, just exit
    %else
    if (*%<work2_ptr> != UsrpDriverSuccess) {
        fprintf(stderr, "%s\n", (char *) %<work3_ptr>); 
        exit(-1);
    }
    %endif
  %endif 
  %%
%endfunction

%% [EOF]
